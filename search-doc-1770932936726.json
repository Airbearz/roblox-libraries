{"searchDocs":[{"title":"Error","type":0,"sectionRef":"#","url":"/roblox-libraries/api/Error","content":"Error An object to represent runtime errors that occur during execution. Promises that experience an error like this will be rejected with an instance of this object.","keywords":"","version":null},{"title":"Remotes","type":0,"sectionRef":"#","url":"/roblox-libraries/api/Remotes","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Remotes","url":"/roblox-libraries/api/Remotes#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Remotes","url":"/roblox-libraries/api/Remotes#new","content":"&lt;/&gt; Remotes.new( group: string, parent: Instance? ) → Remotes Construct a new Remotes instance. If parent is not specified, it will default to ReplicatedStorage.  ","version":null,"tagName":"h3"},{"title":"remoteEvent​","type":1,"pageTitle":"Remotes","url":"/roblox-libraries/api/Remotes#remoteEvent","content":"&lt;/&gt; Remotes.remoteEvent( self: Remotes, name: string ) → RemoteEvent?  On the client this returns a RemoteEvent if there is one On the server, this checks if a RemoteEvent already exists and returns it if it does. If it does not it will create it first then return it.  ","version":null,"tagName":"h3"},{"title":"remoteFunction​","type":1,"pageTitle":"Remotes","url":"/roblox-libraries/api/Remotes#remoteFunction","content":"&lt;/&gt; Remotes.remoteFunction( self: Remotes, name: string ) → RemoteFunction?  On the client this returns a RemoteFunction if there is one On the server, this checks if a RemoteFunction already exists and returns it if it does. If it does not it will create it first then return it.  ","version":null,"tagName":"h3"},{"title":"promiseRemoteEvent​","type":1,"pageTitle":"Remotes","url":"/roblox-libraries/api/Remotes#promiseRemoteEvent","content":"&lt;/&gt; Remotes.promiseRemoteEvent( self: Remotes, name: string, timeout: number? ) → Promise&lt;RemoteEvent &gt; Waits for the RemoteEvent to exist. Will timeout after timeout. This will NOT create a RemoteEvent if it doesn't already exist. local remotes = Remotes.new(&quot;REMOTES&quot;) remotes:promiseRemoteEvent(&quot;RemoteEvent&quot;, 5):andThen(function(remoteEvent) remoteEvent:FireServer(&quot;Hello, Server!&quot;) end)   ","version":null,"tagName":"h3"},{"title":"promiseRemoteFunction​","type":1,"pageTitle":"Remotes","url":"/roblox-libraries/api/Remotes#promiseRemoteFunction","content":"&lt;/&gt; Remotes.promiseRemoteFunction( self: Remotes, name: string, timeout: number? ) → Promise&lt;RemoteFunction &gt; Waits for the RemoteFunction to exist. Will timeout after timeout. This will NOT create a RemoteFunction if it doesn't already exist. local remotes = Remotes.new(&quot;REMOTES&quot;) remotes:promiseRemoteFunction(&quot;RemoteFunction&quot;, 5):andThen(function(remoteFunction) local data = remoteFunction:InvokeServer() print(data) end)  ","version":null,"tagName":"h3"},{"title":"WaitFor","type":0,"sectionRef":"#","url":"/roblox-libraries/api/WaitFor","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"WaitFor","url":"/roblox-libraries/api/WaitFor#properties","content":" ","version":null,"tagName":"h2"},{"title":"Error​","type":1,"pageTitle":"WaitFor","url":"/roblox-libraries/api/WaitFor#Error","content":"&lt;/&gt; WaitFor.Error: { Unparented: string, ParentChanged: string }  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"WaitFor","url":"/roblox-libraries/api/WaitFor#functions","content":" ","version":null,"tagName":"h2"},{"title":"Child​","type":1,"pageTitle":"WaitFor","url":"/roblox-libraries/api/WaitFor#Child","content":"&lt;/&gt; WaitFor.Child( parent: Instance , childName: string, timeout: number? ) → Promise&lt;Instance &gt; Wait for a child to exist within a given parent based on the child name. WaitFor.Child(parent, &quot;SomeObject&quot;):andThen(function(someObject) print(someObject, &quot;now exists&quot;) end):catch(warn)   ","version":null,"tagName":"h3"},{"title":"Children​","type":1,"pageTitle":"WaitFor","url":"/roblox-libraries/api/WaitFor#Children","content":"&lt;/&gt; WaitFor.Children( parent: Instance , childrenNames: {string}, timeout: number? ) → Promise&lt;{Instance }&gt; Wait for all children to exist within the given parent. WaitFor.Children(parent, {&quot;SomeObject01&quot;, &quot;SomeObject02&quot;}):andThen(function(children) local someObject01, someObject02 = table.unpack(children) end) NOTE Once all children are found, a second check is made to ensure that all children are still directly parented to the given parent (since one child's parent might have changed before another child was found). A rejected promise with the WaitFor.Error.ParentChanged error will be thrown if any parents of the children no longer match the given parent.  ","version":null,"tagName":"h3"},{"title":"Descendant​","type":1,"pageTitle":"WaitFor","url":"/roblox-libraries/api/WaitFor#Descendant","content":"&lt;/&gt; WaitFor.Descendant( parent: Instance , descendantName: string, timeout: number? ) → Promise&lt;Instance &gt; Wait for a descendant to exist within a given parent. This is similar toWaitFor.Child, except it looks for all descendants instead of immediate children. WaitFor.Descendant(parent, &quot;SomeDescendant&quot;):andThen(function(someDescendant) print(&quot;SomeDescendant now exists&quot;) end)   ","version":null,"tagName":"h3"},{"title":"Descendants​","type":1,"pageTitle":"WaitFor","url":"/roblox-libraries/api/WaitFor#Descendants","content":"&lt;/&gt; WaitFor.Descendants( parent: Instance , descendantNames: {string}, timeout: number? ) → Promise&lt;{Instance }&gt; Wait for all descendants to exist within a given parent. WaitFor.Descendants(parent, {&quot;SomeDescendant01&quot;, &quot;SomeDescendant02&quot;}):andThen(function(descendants) local someDescendant01, someDescendant02 = table.unpack(descendants) end) NOTE Once all descendants are found, a second check is made to ensure that none of the instances have moved outside of the parent (since one instance might change before another instance is found). A rejected promise with the WaitFor.Error.ParentChanged error will be thrown if any of the instances are no longer descendants of the given parent.  ","version":null,"tagName":"h3"},{"title":"PrimaryPart​","type":1,"pageTitle":"WaitFor","url":"/roblox-libraries/api/WaitFor#PrimaryPart","content":"&lt;/&gt; WaitFor.PrimaryPart( model: Model , timeout: number? ) → Promise&lt;Instance &gt; Wait for the PrimaryPart of a model to exist. WaitFor.PrimaryPart(model):andThen(function(primaryPart) print(primaryPart == model.PrimaryPart) end)   ","version":null,"tagName":"h3"},{"title":"ObjectValue​","type":1,"pageTitle":"WaitFor","url":"/roblox-libraries/api/WaitFor#ObjectValue","content":"&lt;/&gt; WaitFor.ObjectValue( objectValue: ObjectValue , timeout: number? ) → Promise&lt;Instance &gt; Wait for the Value of an ObjectValue to exist. WaitFor.ObjectValue(someObjectValue):andThen(function(value) print(&quot;someObjectValue's value is&quot;, value) end)   ","version":null,"tagName":"h3"},{"title":"Custom​","type":1,"pageTitle":"WaitFor","url":"/roblox-libraries/api/WaitFor#Custom","content":"&lt;/&gt; WaitFor.Custom( predicate: () → T?, timeout: number? ) → Promise&lt;T&gt; Wait for the given predicate function to return a non-nil value of of type T. The predicate is fired every RunService Heartbeat step. -- Example, waiting for some property to be set: WaitFor.Custom(function() return vectorForce.Attachment0 end):andThen(function(a0) print(a0) end)  ","version":null,"tagName":"h3"},{"title":"Janitor","type":0,"sectionRef":"#","url":"/roblox-libraries/api/Janitor","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#properties","content":" ","version":null,"tagName":"h2"},{"title":"CurrentlyCleaning​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#CurrentlyCleaning","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Janitor.CurrentlyCleaning: boolean Whether or not the Janitor is currently cleaning up.  ","version":null,"tagName":"h3"},{"title":"SuppressInstanceReDestroy​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#SuppressInstanceReDestroy","content":"since 1.15.4 &lt;/&gt; Janitor.SuppressInstanceReDestroy: boolean Whether or not you want to suppress the re-destroying of instances. Default is false, which is the original behavior.  ","version":null,"tagName":"h3"},{"title":"UnsafeThreadCleanup​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#UnsafeThreadCleanup","content":"since 1.18.0 &lt;/&gt; Janitor.UnsafeThreadCleanup: boolean Whether or not to use the unsafe fast defer function for cleaning up threads. This might be able to throw, so be careful. If you're getting any thread related errors, chances are it is this. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#new","content":"&lt;/&gt; Janitor.new() → Janitor Instantiates a new Janitor object.  ","version":null,"tagName":"h3"},{"title":"Is​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#Is","content":"&lt;/&gt; Janitor.Is( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. Determines if the passed object is a Janitor. This checks the metatable directly.  ","version":null,"tagName":"h3"},{"title":"instanceof​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#instanceof","content":"&lt;/&gt; Janitor.instanceof( object: unknown-- The object you are checking. ) → boolean-- true if object is a Janitor. An alias for Janitor.Is. This is intended for roblox-ts support.  ","version":null,"tagName":"h3"},{"title":"Add​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#Add","content":"&lt;/&gt; Janitor:Add( object: T,-- The object you want to clean up. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown-- The index that can be used to clean up the object manually. ) → T-- The object that was passed as the first argument. Adds an object to Janitor for later cleanup, where methodName is the key of the method within object which should be called at cleanup time. If the methodName is true the object itself will be called if it's a function or have task.cancel called on it if it is a thread. If passed an index it will occupy a namespace which can be Remove()d or overwritten. Returns the object. Note Objects not given an explicit methodName will be passed into the typeof function for a very naive typecheck. RBXConnections will be assigned to &quot;Disconnect&quot;, functions and threads will be assigned to true, and everything else will default to &quot;Destroy&quot;. Not recommended, but hey, you do you. Luau: local Workspace = game:GetService(&quot;Workspace&quot;) local TweenService = game:GetService(&quot;TweenService&quot;) local obliterator = Janitor.new() local part = Workspace:FindFirstChild(&quot;Part&quot;) :: Part -- Queue the Part to be Destroyed at Cleanup time obliterator:Add(part, &quot;Destroy&quot;) -- Queue function to be called with `true` methodName obliterator:Add(print, true) -- Close a thread. obliterator:Add(task.defer(function() while true do print(&quot;Running!&quot;) task.wait(0.5) end end), true) -- This implementation allows you to specify behavior for any object obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Cancel&quot;) -- By passing an index, the object will occupy a namespace -- If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator:Add(TweenService:Create(part, TweenInfo.new(1), {Size = Vector3.one}), &quot;Destroy&quot;, &quot;CurrentTween&quot;) TypeScript: import { Workspace, TweenService } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ CurrentTween: Tween }&gt;(); const part = Workspace.FindFirstChild(&quot;Part&quot;) as Part; // Queue the part to be Destroyed at Cleanup time obliterator.Add(part, &quot;Destroy&quot;); // Queue function to be called with `true` methodName obliterator.Add(print, true); // Close a thread. obliterator.Add(task.defer(() =&gt; { while (true) { print(&quot;Running!&quot;); task.wait(0.5); } }), true); // This implementation allows you to specify behavior for any object obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Cancel&quot;); // By passing an index, the object will occupy a namespace // If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing obliterator.Add(TweenService.Create(part, new TweenInfo(1), { Size: Vector3.one }), &quot;Destroy&quot;, &quot;CurrentTween&quot;);   ","version":null,"tagName":"h3"},{"title":"AddObject​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#AddObject","content":"since v1.16.0 &lt;/&gt; Janitor:AddObject( constructor: {new: (A...) → T},-- The constructor for the object you want to add to the Janitor. methodName?: boolean | string,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. index?: unknown,-- The index that can be used to clean up the object manually. ...: A...-- The arguments that will be passed to the constructor. ) → T-- The object that was passed as the first argument. Constructs an object for you and adds it to the Janitor. It's really just shorthand for Janitor:Add(object.new(), methodName, index). Luau: local obliterator = Janitor.new() local subObliterator = obliterator:AddObject(Janitor, &quot;Destroy&quot;) -- subObliterator is another Janitor! TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); const subObliterator = obliterator.AddObject(Janitor, &quot;Destroy&quot;);   ","version":null,"tagName":"h3"},{"title":"Get​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#Get","content":"&lt;/&gt; Janitor:Get( index: unknown-- The index that the object is stored under. ) → unknown?-- This will return the object if it is found, but it won't return anything if it doesn't exist. Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the task using __index. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:Get(&quot;Baseplate&quot;)) -- Returns Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.Get(&quot;Baseplate&quot;)); // Returns Baseplate.   ","version":null,"tagName":"h3"},{"title":"AddPromise​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#AddPromise","content":"&lt;/&gt; Janitor:AddPromise( promiseObject: Promise,-- The promise you want to add to the Janitor. index?: unknown-- The index that can be used to clean up the object manually. ) → Promise Adds a Promise to the Janitor. If the Janitor is cleaned up and the Promise is not completed, the Promise will be cancelled. Luau: local obliterator = Janitor.new() obliterator:AddPromise(Promise.delay(3)):andThenCall(print, &quot;Finished!&quot;):catch(warn) task.wait(1) obliterator:Cleanup() TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.AddPromise(Promise.delay(3)).andThenCall(print, &quot;Finished!&quot;).catch(warn); task.wait(1); obliterator.Cleanup();  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor##","content":"Type\tDescriptionNotAPromiseError\tThrown if the promise is not a Promise.  ","version":null,"tagName":"h3"},{"title":"Remove​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#Remove","content":"&lt;/&gt; Janitor:Remove( index: unknown-- The index you want to remove. ) → Janitor Cleans up whatever Object was set to this namespace by the 3rd parameter of Janitor.Add. Luau: local obliterator = Janitor.new() obliterator:Add(workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) obliterator:Remove(&quot;Baseplate&quot;) TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); obliterator.Remove(&quot;Baseplate&quot;);   ","version":null,"tagName":"h3"},{"title":"RemoveNoClean​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#RemoveNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveNoClean( index: unknown-- The index you are removing. ) → Janitor Removes an object from the Janitor without running a cleanup. Luau local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed!&quot;) end, true, &quot;Function&quot;) obliterator:RemoveNoClean(&quot;Function&quot;) -- Does not print. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Function: () =&gt; void }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed!&quot;), true, &quot;Function&quot;); obliterator.RemoveNoClean(&quot;Function&quot;); // Does not print.   ","version":null,"tagName":"h3"},{"title":"RemoveList​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#RemoveList","content":"since v1.14.0 &lt;/&gt; Janitor:RemoveList( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot; TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOp = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOp, Two: NoOp, Three: NoOp }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveList(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Prints &quot;Removed One&quot;, &quot;Removed Two&quot;, and &quot;Removed Three&quot;   ","version":null,"tagName":"h3"},{"title":"RemoveListNoClean​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#RemoveListNoClean","content":"since v1.15.0 &lt;/&gt; Janitor:RemoveListNoClean( ...: unknown-- The indices you want to remove. ) → Janitor Cleans up multiple objects at once without running their cleanup. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Removed One&quot;) end, true, &quot;One&quot;) obliterator:Add(function() print(&quot;Removed Two&quot;) end, true, &quot;Two&quot;) obliterator:Add(function() print(&quot;Removed Three&quot;) end, true, &quot;Three&quot;) obliterator:RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;) -- Nothing is printed. TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; type NoOperation = () =&gt; void const obliterator = new Janitor&lt;{ One: NoOperation, Two: NoOperation, Three: NoOperation }&gt;(); obliterator.Add(() =&gt; print(&quot;Removed One&quot;), true, &quot;One&quot;); obliterator.Add(() =&gt; print(&quot;Removed Two&quot;), true, &quot;Two&quot;); obliterator.Add(() =&gt; print(&quot;Removed Three&quot;), true, &quot;Three&quot;); obliterator.RemoveListNoClean(&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); // Nothing is printed.   ","version":null,"tagName":"h3"},{"title":"GetAll​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#GetAll","content":"since v1.15.1 &lt;/&gt; Janitor:GetAll() → {[any]: any} Returns a frozen copy of the Janitor's indices. Luau: local obliterator = Janitor.new() obliterator:Add(Workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(obliterator:GetAll().Baseplate) -- Prints Baseplate. TypeScript: import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(obliterator.GetAll().Baseplate); // Prints Baseplate.   ","version":null,"tagName":"h3"},{"title":"Cleanup​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#Cleanup","content":"&lt;/&gt; Janitor:Cleanup() → () Calls each object's methodName (or calls the object if methodName == true) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor object (so it can be used as a destructor callback). Luau: obliterator:Cleanup() -- Valid. obliterator() -- Also valid. TypeScript: obliterator.Cleanup() // TypeScript version doesn't support the __call method of cleaning.   ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#Destroy","content":"&lt;/&gt; Janitor:Destroy() → () Calls Janitor.Cleanup and renders the Janitor unusable. Metatable Removal Running this will make any further attempts to call a method of Janitor error.  ","version":null,"tagName":"h3"},{"title":"LinkToInstance​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#LinkToInstance","content":"&lt;/&gt; Janitor:LinkToInstance( object: Instance ,-- The instance you want to link the Janitor to. allowMultiple?: boolean-- Whether or not to allow multiple links on the same Janitor. ) → RBXScriptConnection -- A RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance. &quot;Links&quot; this Janitor to an Instance, such that the Janitor will Cleanup when the Instance is Destroy()d and garbage collected. A Janitor may only be linked to one instance at a time, unless allowMultiple is true. When called with a truthy allowMultiple parameter, the Janitor will &quot;link&quot; the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy allowMultiple parameter, the Janitor will overwrite the previous link which was also called with a falsy allowMultiple parameter, if applicable. Luau: local obliterator = Janitor.new() obliterator:Add(function() print(&quot;Cleaning up!&quot;) end, true) do local folder = Instance.new(&quot;Folder&quot;) obliterator:LinkToInstance(folder) folder:Destroy() end TypeScript: import { Janitor } from &quot;@rbxts/janitor&quot;; const obliterator = new Janitor(); obliterator.Add(() =&gt; print(&quot;Cleaning up!&quot;), true); { const folder = new Instance(&quot;Folder&quot;); obliterator.LinkToInstance(folder, false); folder.Destroy(); }   ","version":null,"tagName":"h3"},{"title":"LinkToInstances​","type":1,"pageTitle":"Janitor","url":"/roblox-libraries/api/Janitor#LinkToInstances","content":"&lt;/&gt; Janitor:LinkToInstances( ...: Instance -- All the Instances you want linked. ) → Janitor-- A new Janitor that can be used to manually disconnect all LinkToInstances. Links several instances to a new Janitor, which is then returned. ","version":null,"tagName":"h3"},{"title":"Promise","type":0,"sectionRef":"#","url":"/roblox-libraries/api/Promise","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#types","content":" ","version":null,"tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#Status","content":"enum &lt;/&gt; interface Status { Started: &quot;Started&quot;-- The Promise is executing, and not settled yet. Resolved: &quot;Resolved&quot;-- The Promise finished successfully. Rejected: &quot;Rejected&quot;-- The Promise was rejected. Cancelled: &quot;Cancelled&quot;-- The Promise was cancelled before it finished. } An enum value used to represent the Promise's status. ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#properties","content":" ","version":null,"tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#Status","content":"This item is read only and cannot be modified. Read Only enums &lt;/&gt; Promise.Status: Status A table containing all members of the Status enum, e.g., Promise.Status.Resolved. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#new","content":"&lt;/&gt; Promise.new(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise Construct a new Promise that will be resolved or rejected with the given callbacks. If you resolve with a Promise, it will be chained onto. You can safely yield within the executor function and it will not block the creating thread. local myFunction() return Promise.new(function(resolve, reject, onCancel) wait(1) resolve(&quot;Hello world!&quot;) end) end myFunction():andThen(print) You do not need to use pcall within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If error() is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into Promise.Error(Promise.Error.Kind.ExecutionError) objects for tracking debug information. You may register an optional cancellation hook by using the onCancel argument: This should be used to abort any ongoing operations leading up to the promise being settled. Call the onCancel function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled. onCancel returns true if the Promise was already cancelled when you called onCancel. Calling onCancel with no argument will not override a previously set cancellation hook, but it will still return true if the Promise is currently cancelled. You can set the cancellation hook at any time before resolving. When a promise is cancelled, calls to resolve or reject will be ignored, regardless of if you set a cancellation hook or not. CAUTION If the Promise is cancelled, the executor thread is closed with coroutine.close after the cancellation hook is called. You must perform any cleanup code in the cancellation hook: any time your executor yields, it may never resume.  ","version":null,"tagName":"h3"},{"title":"defer​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#defer","content":"&lt;/&gt; Promise.defer(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise The same as Promise.new, except execution begins after the next Heartbeat event. This is a spiritual replacement for spawn, but it does not suffer from the same issues as spawn. local function waitForChild(instance, childName, timeout) return Promise.defer(function(resolve, reject) local child = instance:WaitForChild(childName, timeout) ;(child and resolve or reject)(child) end) end   ","version":null,"tagName":"h3"},{"title":"resolve​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#resolve","content":"&lt;/&gt; Promise.resolve(...: any) → Promise&lt;...any&gt; Creates an immediately resolved Promise with the given value. -- Example using Promise.resolve to deliver cached values: function getSomething(name) if cache[name] then return Promise.resolve(cache[name]) else return Promise.new(function(resolve, reject) local thing = getTheThing() cache[name] = thing resolve(thing) end) end end   ","version":null,"tagName":"h3"},{"title":"reject​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#reject","content":"&lt;/&gt; Promise.reject(...: any) → Promise&lt;...any&gt; Creates an immediately rejected Promise with the given value. CAUTION Something needs to consume this rejection (i.e. :catch() it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.  ","version":null,"tagName":"h3"},{"title":"try​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#try","content":"&lt;/&gt; Promise.try( callback: (...: T...) → ...any, ...: T...-- Additional arguments passed to callback ) → Promise Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback. INFO Promise.try is similar to Promise.promisify, except the callback is invoked immediately instead of returning a new function. Promise.try(function() return math.random(1, 2) == 1 and &quot;ok&quot; or error(&quot;Oh an error!&quot;) end) :andThen(function(text) print(text) end) :catch(function(err) warn(&quot;Something went wrong&quot;) end)   ","version":null,"tagName":"h3"},{"title":"all​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#all","content":"&lt;/&gt; Promise.all(promises: {Promise&lt;T&gt;}) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a new promise that: is resolved after all input promises resolve. is rejected if any input promises reject. INFO Only the first return value from each promise will be present in the resulting array. After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.all(promises)   ","version":null,"tagName":"h3"},{"title":"fold​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#fold","content":"since v3.1.0 &lt;/&gt; Promise.fold( list: {T | Promise&lt;T&gt;}, reducer: ( accumulator: U, value: T, index: number ) → U | Promise&lt;U&gt;, initialValue: U ) → () Folds an array of values or promises into a single value. The array is traversed sequentially. The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value. The folding will stop at the first rejection encountered. local basket = {&quot;blueberry&quot;, &quot;melon&quot;, &quot;pear&quot;, &quot;melon&quot;} Promise.fold(basket, function(cost, fruit) if fruit == &quot;blueberry&quot; then return cost -- blueberries are free! else -- call a function that returns a promise with the fruit price return fetchPrice(fruit):andThen(function(fruitCost) return cost + fruitCost end) end end, 0)   ","version":null,"tagName":"h3"},{"title":"some​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#some","content":"&lt;/&gt; Promise.some( promises: {Promise&lt;T&gt;}, count: number ) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as count Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers. count 0 results in an empty array. The resultant array will never have more than count elements. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve   ","version":null,"tagName":"h3"},{"title":"any​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#any","content":"&lt;/&gt; Promise.any(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as any of the input Promises resolves. It will reject only if all input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers. Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with 1 count, except the Promise resolves with the value directly instead of an array with one element. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)   ","version":null,"tagName":"h3"},{"title":"allSettled​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#allSettled","content":"&lt;/&gt; Promise.allSettled(promises: {Promise&lt;T&gt;}) → Promise&lt;{Status}&gt; Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping promise:finally over the array of Promises. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.allSettled(promises)   ","version":null,"tagName":"h3"},{"title":"race​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#race","content":"&lt;/&gt; Promise.race(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects. WARNING If the first Promise to settle from the array settles with a rejection, the resulting Promise from race will reject. If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use Promise.any or Promise.some instead. All other Promises that don't win the race will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.race(promises) -- Only returns 1st value to resolve or reject   ","version":null,"tagName":"h3"},{"title":"each​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#each","content":"since 3.0.0 &lt;/&gt; Promise.each( list: {T | Promise&lt;T&gt;}, predicate: ( value: T, index: number ) → U | Promise&lt;U&gt; ) → Promise&lt;{U}&gt; Iterates serially over the given an array of values, calling the predicate callback on each value before continuing. If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item in the array. INFO Promise.each is similar to Promise.all, except the Promises are ran in order instead of all at once. But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time. The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value. Promise.each({ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot; }, function(value, index) return Promise.delay(1):andThen(function() print((&quot;%d) Got %s!&quot;):format(index, value)) end) end) --[[ (1 second passes) &gt; 1) Got foo! (1 second passes) &gt; 2) Got bar! (1 second passes) &gt; 3) Got baz! (1 second passes) &gt; 4) Got qux! ]] If the Promise a predicate returns rejects, the Promise from Promise.each is also rejected with the same value. If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value. If a Promise in the array of values is already Rejected when Promise.each is called, Promise.each rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when Promise.each is called, Promise.each rejects with Promise.Error(Promise.Error.Kind.AlreadyCancelled). If a Promise in the array of values is Started at first, but later rejects, Promise.each will reject with that value and iteration will not continue once iteration encounters that value. Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values. If this Promise returned from Promise.each rejects or is cancelled for any reason, the following are true: Iteration will not continue. Any Promises within the array of values will now be cancelled if they have no other consumers. The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.  ","version":null,"tagName":"h3"},{"title":"is​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#is","content":"&lt;/&gt; Promise.is(object: any) → boolean-- true if the given object is a Promise. Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an andThen method.  ","version":null,"tagName":"h3"},{"title":"promisify​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#promisify","content":"&lt;/&gt; Promise.promisify(callback: (...: any) → ...any) → (...: any) → Promise Wraps a function that yields into one that returns a Promise. Any errors that occur while executing the function will be turned into rejections. INFO Promise.promisify is similar to Promise.try, except the callback is returned as a callable function instead of being invoked immediately. local sleep = Promise.promisify(wait) sleep(1):andThen(print) local isPlayerInGroup = Promise.promisify(function(player, groupId) return player:IsInGroup(groupId) end)   ","version":null,"tagName":"h3"},{"title":"delay​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#delay","content":"&lt;/&gt; Promise.delay(seconds: number) → Promise&lt;number&gt; Returns a Promise that resolves after seconds seconds have passed. The Promise resolves with the actual amount of time that was waited. This function is not a wrapper around wait. Promise.delay uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler. WARNING Passing NaN, infinity, or a number less than 1/60 is equivalent to passing 1/60. Promise.delay(5):andThenCall(print, &quot;This prints after 5 seconds&quot;)   ","version":null,"tagName":"h3"},{"title":"retry​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#retry","content":"since 3.0.0 &lt;/&gt; Promise.retry( callback: (...: P) → Promise&lt;T&gt;, times: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise. local function canFail(a, b, c) return Promise.new(function(resolve, reject) -- do something that can fail local failed, thing = doSomethingThatCanFail(a, b, c) if failed then reject(&quot;it failed&quot;) else resolve(thing) end end) end local MAX_RETRIES = 10 local value = Promise.retry(canFail, MAX_RETRIES, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) -- args to send to canFail   ","version":null,"tagName":"h3"},{"title":"retryWithDelay​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#retryWithDelay","content":"since v3.2.0 &lt;/&gt; Promise.retryWithDelay( callback: (...: P) → Promise&lt;T&gt;, times: number, seconds: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, waiting seconds seconds between each retry, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise.  ","version":null,"tagName":"h3"},{"title":"fromEvent​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#fromEvent","content":"since 3.0.0 &lt;/&gt; Promise.fromEvent( event: Event,-- Any object with a Connect method. This includes all Roblox events. predicate?: (...: P) → boolean-- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again. ) → Promise&lt;P&gt; Converts an event into a Promise which resolves the next time the event fires. The optional predicate callback, if passed, will receive the event arguments and should return true or false, based on if this fired event should resolve the Promise or not. If true, the Promise resolves. If false, nothing happens and the predicate will be rerun the next time the event fires. The Promise will resolve with the event arguments. TIP This function will work given any object with a Connect method. This includes all Roblox events. -- Creates a Promise which only resolves when `somePart` is touched -- by a part named `&quot;Something specific&quot;`. return Promise.fromEvent(somePart.Touched, function(part) return part.Name == &quot;Something specific&quot; end)   ","version":null,"tagName":"h3"},{"title":"onUnhandledRejection​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#onUnhandledRejection","content":"since v3.2.0 &lt;/&gt; Promise.onUnhandledRejection( callback: ( promise: Promise, ...: any )-- A callback that runs when an unhandled rejection happens. ) → () → ()-- Function that unregisters the callback when called Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise is rejected, and the rejection is not observed with :catch. The callback is called with the actual promise that rejected, followed by the rejection values.  ","version":null,"tagName":"h3"},{"title":"timeout​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#timeout","content":"&lt;/&gt; Promise:timeout( seconds: number, rejectionValue?: any-- The value to reject with if the timeout is reached ) → Promise Returns a new Promise that resolves if the chained Promise resolves within seconds seconds, or rejects if execution time exceeds seconds. The chained Promise will be cancelled if the timeout is reached. Rejects with rejectionValue if it is non-nil. If a rejectionValue is not given, it will reject with a Promise.Error(Promise.Error.Kind.TimedOut). This can be checked with [[Error.isKind]]. getSomething():timeout(5):andThen(function(something) -- got something and it only took at max 5 seconds end):catch(function(e) -- Either getting something failed or the time was exceeded. if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then warn(&quot;Operation timed out!&quot;) else warn(&quot;Operation encountered an error!&quot;) end end) Sugar for: Promise.race({ Promise.delay(seconds):andThen(function() return Promise.reject( rejectionValue == nil and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut }) or rejectionValue ) end), promise })   ","version":null,"tagName":"h3"},{"title":"getStatus​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#getStatus","content":"&lt;/&gt; Promise:getStatus() → Status Returns the current Promise status.  ","version":null,"tagName":"h3"},{"title":"andThen​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#andThen","content":"&lt;/&gt; Promise:andThen( successHandler: (...: any) → ...any, failureHandler?: (...: any) → ...any ) → Promise&lt;...any&gt; Chains onto an existing Promise and returns a new Promise. WARNING Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call tostring on it first. You can return a Promise from the success or failure handler and it will be chained onto. Calling andThen on a cancelled Promise returns a cancelled Promise. TIP If the Promise returned by andThen is cancelled, successHandler and failureHandler will not run. To run code no matter what, use Promise:finally.  ","version":null,"tagName":"h3"},{"title":"catch​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#catch","content":"&lt;/&gt; Promise:catch(failureHandler: (...: any) → ...any) → Promise&lt;...any&gt; Shorthand for Promise:andThen(nil, failureHandler). Returns a Promise that resolves if the failureHandler worked without encountering an additional error. WARNING Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call tostring on it first. Calling catch on a cancelled Promise returns a cancelled Promise. TIP If the Promise returned by catch is cancelled, failureHandler will not run. To run code no matter what, use Promise:finally.  ","version":null,"tagName":"h3"},{"title":"tap​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#tap","content":"&lt;/&gt; Promise:tap(tapHandler: (...: any) → ...any) → Promise&lt;...any&gt; Similar to Promise.andThen, except the return value is the same as the value passed to the handler. In other words, you can insert a :tap into a Promise chain without affecting the value that downstream Promises receive. getTheValue() :tap(print) :andThen(function(theValue) print(&quot;Got&quot;, theValue, &quot;even though print returns nil!&quot;) end) If you return a Promise from the tap handler callback, its value will be discarded but tap will still wait until it resolves before passing the original value through.  ","version":null,"tagName":"h3"},{"title":"andThenCall​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#andThenCall","content":"&lt;/&gt; Promise:andThenCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Attaches an andThen handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded. promise:andThenCall(someFunction, &quot;some&quot;, &quot;arguments&quot;) This is sugar for promise:andThen(function() return someFunction(&quot;some&quot;, &quot;arguments&quot;) end)   ","version":null,"tagName":"h3"},{"title":"andThenReturn​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#andThenReturn","content":"&lt;/&gt; Promise:andThenReturn( ...: any-- Values to return from the function ) → Promise Attaches an andThen handler to this Promise that discards the resolved value and returns the given value from it. promise:andThenReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:andThen(function() return &quot;some&quot;, &quot;values&quot; end) CAUTION Promises are eager, so if you pass a Promise to andThenReturn, it will begin executing before andThenReturn is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into andThenReturn, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].  ","version":null,"tagName":"h3"},{"title":"cancel​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#cancel","content":"&lt;/&gt; Promise:cancel() → () Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled. Cancellations will propagate upwards and downwards through chained promises. Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call andThen twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled. promise:cancel()   ","version":null,"tagName":"h3"},{"title":"finally​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#finally","content":"&lt;/&gt; Promise:finally(finallyHandler: (status: Status) → ...any) → Promise&lt;...any&gt; Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, or cancelled. Returns a new Promise that: resolves with the same values that this Promise resolves with. rejects with the same values that this Promise rejects with. is cancelled if this Promise is cancelled. If the value you return from the handler is a Promise: We wait for the Promise to resolve, but we ultimately discard the resolved value. If the returned Promise rejects, the Promise returned from finally will reject with the rejected value from the returned promise. If the finally Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too. Otherwise, the return value from the finally handler is entirely discarded. Cancellation As of Promise v4, Promise:finally does not count as a consumer of the parent Promise for cancellation purposes. This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers, the Promise is cancelled and the finally callbacks run then and there. Cancellation still propagates through the finally Promise though: if you cancel the finally Promise, it can cancel its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the finally Promise will also be cancelled. local thing = createSomething() doSomethingWith(thing) :andThen(function() print(&quot;It worked!&quot;) -- do something.. end) :catch(function() warn(&quot;Oh no it failed!&quot;) end) :finally(function() -- either way, destroy thing thing:Destroy() end)   ","version":null,"tagName":"h3"},{"title":"finallyCall​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#finallyCall","content":"&lt;/&gt; Promise:finallyCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Same as andThenCall, except for finally. Attaches a finally handler to this Promise that calls the given callback with the predefined arguments.  ","version":null,"tagName":"h3"},{"title":"finallyReturn​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#finallyReturn","content":"&lt;/&gt; Promise:finallyReturn( ...: any-- Values to return from the function ) → Promise Attaches a finally handler to this Promise that discards the resolved value and returns the given value from it. promise:finallyReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:finally(function() return &quot;some&quot;, &quot;values&quot; end)   ","version":null,"tagName":"h3"},{"title":"awaitStatus​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#awaitStatus","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:awaitStatus() → ( Status,-- The Status representing the fate of the Promise ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.  ","version":null,"tagName":"h3"},{"title":"await​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#await","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:await() → ( boolean,-- true if the Promise successfully resolved ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with. CAUTION If the Promise gets cancelled, this function will return false, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead. local worked, value = getTheValue():await() if worked then print(&quot;got&quot;, value) else warn(&quot;it failed&quot;) end   ","version":null,"tagName":"h3"},{"title":"expect​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#expect","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:expect() → ...any-- The values the Promise resolved with. Yields the current thread until the given Promise completes. Returns the values that the promise resolved with. local worked = pcall(function() print(&quot;got&quot;, getTheValue():expect()) end) if not worked then warn(&quot;it failed&quot;) end This is essentially sugar for: select(2, assert(promise:await())) Errors if the Promise rejects or gets cancelled. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise##","content":"Type\tDescriptionany\tErrors with the rejection value if this Promise rejects or gets cancelled.  ","version":null,"tagName":"h3"},{"title":"now​","type":1,"pageTitle":"Promise","url":"/roblox-libraries/api/Promise#now","content":"&lt;/&gt; Promise:now( rejectionValue?: any-- The value to reject with if the Promise isn't resolved ) → Promise Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling :now(). This can be used to ensure your andThen handler occurs on the same frame as the root Promise execution. doSomething() :now() :andThen(function(value) print(&quot;Got&quot;, value, &quot;synchronously.&quot;) end) If this Promise is still running, Rejected, or Cancelled, the Promise returned from :now() will reject with the rejectionValue if passed, otherwise with a Promise.Error(Promise.Error.Kind.NotResolvedInTime). This can be checked with [[Error.isKind]]. ","version":null,"tagName":"h3"}],"options":{"id":"default"}}